{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p> I'm Tomas Rojo, nice to meet you! \ud83d\udc4b </p> <p> I'm a DevOps Engineer from Argentina. \ud83c\udde6\ud83c\uddf7 </p> <p> Currently living in Amsterdam, Netherlands. \ud83c\uddf3\ud83c\uddf1 </p> <p> Main focus is Python development, automating stuff and containers </p>"},{"location":"work-experience/","title":"Work Experience","text":""},{"location":"work-experience/#_1","title":"Work Experience","text":""},{"location":"work-experience/#cerqlar-devops-engineer","title":"CerQlar - DevOps Engineer","text":"<p>September 2024 - Present</p> <ul> <li>Introduced temporary environments for different microservices allowing developers to easily deploy their features</li> <li>Cluster management with Kubernetes, Helm, Terraform, </li> </ul> <p>Stack: Python - Docker - Kubernetes - Google Cloud - Terraform - Github</p>"},{"location":"work-experience/#_2","title":"Work Experience","text":""},{"location":"work-experience/#h2b-it-solutions-software-developer","title":"H2B IT Solutions - Software Developer","text":"<p>August 2022 - August 2024</p> <ul> <li>Contributed to the development of a CRM bilt in Django, serving a large user base</li> <li>Containerized applications using Docker + Docker Compose and trimmed down image size up to 50%</li> <li>Developed various REST APIs in Flask and FastAPI</li> </ul> <p>Stack: Python - Django - Flask - FastAPI - PostgreSQL - Docker - Gitlab</p>"},{"location":"work-experience/#_3","title":"Work Experience","text":""},{"location":"work-experience/#high-browse-software-developer","title":"High-Browse - Software Developer","text":"<p>March 2022 - July 2022</p> <ul> <li>Developed a Flask monitoring tool that aggregated and analyzed data from multiple tables to provide up-to-date metrics and insights</li> <li>Enhanced the performance of the initial application by implementing a multithreaded approach for data download and processing, resulting in a 80% faster processing</li> </ul> <p>Stack: Python - Flask - MSSQL - PostgreSQL - Github</p> <p></p>"},{"location":"blog/2024/11/06/repository-pattern/","title":"The Repository Pattern","text":"<p>Hey there, friend! Today, I want to talk to you about a design Pattern that's really useful in software development: the Repository Pattern.</p>"},{"location":"blog/2024/11/06/repository-pattern/#introduction","title":"Introduction","text":"<p>So, what is the Repository Pattern? In a nutshell, it's a way to abstract away the data access layer in your application. Think of it like a library where you can store and retrieve data.</p> <p>Imagine you're building a simple blog application. You have a list of posts, and you want to be able to add, remove, and retrieve posts from the database. Without the Repository Pattern, you might have code like this:</p> PostRepository models/post.py<pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Post:\n    id: str\n    title: str\n    content: str\n</code></pre> repository.py<pre><code>from models.post import Post\n\n\nclass PostRepository:\n    def __init__(self) -&gt; None:\n        self.posts: dict[str, str] = {}\n\n    def add(self, post: Post) -&gt; None:\n        self.posts[post.id] = post\n\n    def get(self, id: str) -&gt; Post:\n        try:\n            return self.posts[id]\n        except KeyError as e:\n            raise Exception(f\"Book with ID {id!r} not found\") from e\n</code></pre> <p>This code is not that bad, but it has some problems...</p> <p>For one, it's tightly coupled to the database (in this case, a dictionary of posts, but it could be a Postgres database and even a CSV file). If you wanted to switch to a different database, you'd have to rewrite a lot of code.</p> <p>And what if you wanted to add some extra functionality, like caching or logging? You'd have to add it to the class, which could make it harder to maintain.</p>"},{"location":"blog/2024/11/06/repository-pattern/#repository-pattern-to-our-rescue","title":"Repository Pattern to our rescue","text":"<p>Here is where the Repository Pattern comes in. It is an abstraction layer between your application code and the data access layer. Basically, it provides a way to interact with the data without knowing how it's stored or retrieved.</p>"},{"location":"blog/2024/11/06/repository-pattern/#first-step","title":"First step","text":"<p>I generally start with an abstract repository or interface, that will be used after to have our concrete implementations of accesing our data.</p> <p>In Python, an Abstract Base Class (ABC) is like a blueprint for other classes. It defines methods (using the decorator <code>@abstractmethod</code>) that any subclass must implement, but it doesn't actually provide any working code itself. It\u2019s a way to say, \u201cAny class that inherits from me must have these methods.\u201d</p> <p>By the way, the abstract methods can have some functionality, if really needed.</p> <p>Let's see some code:</p> abstract_post_repository.py<pre><code>from abc import ABC, abstractmethod\n\nfrom models.post import Post\n\n\nclass AbstractPostRepository(ABC):\n\n    @abstractmethod\n    def add(self, post: Post) -&gt; None:\n        raise NotImplementedError\n\n    @abstractmethod\n    def get(self, id: str) -&gt; Post:\n        raise NotImplementedError\n</code></pre>"},{"location":"blog/2024/11/06/repository-pattern/#what-next","title":"What next?","text":"<p>Now, let's create some classes that actually do the work. We\u2019ll make a simple in-memory repository that stores posts in a Python dictionary and a repository that will use a relational database.</p> PostFake RepositorySQL Repository models/post.py<pre><code>from dataclasses import dataclass\n\nfrom models.post import Post\n\n\n@dataclass\nclass Post:\n    id: str\n    title: str\n    content: str\n</code></pre> fake_post_repository.py<pre><code>from models.post import Post\n\n\nclass FakePostRepository(AbstractPostRepository):\n    def __init__(self) -&gt; None:\n        self.posts: dict[str, str] = {}\n\n    def add(self, post: Post) -&gt; None:\n        self.posts[post.id] = post\n\n    def get(self, id: str) -&gt; Post:\n        try:\n            return self.posts[id]\n        except KeyError as e:\n            raise Exception(f\"Book with ID {id!r} not found\") from e\n</code></pre> sql_post_repository.py<pre><code>from models.post import Post\n\n\nclass SqlPostRepository(AbstractPostRepository):\n    def __init__(self, session) -&gt; None:\n        self._session = session\n\n    def add(self, post: Post) -&gt; None:\n        # SQL code to add the post to the database\n        pass\n\n    def get(self, id: str) -&gt; Post:\n        # SQL code to retrieve the post from the database\n        pass\n</code></pre> <p>In this example, the <code>FakePostRepository</code> class is a fake implementation of the Repository Pattern. It's used for testing purposes, and it simulates the behavior of a real Repository.</p> <p>Tip</p> <p>Creating fake implementations for your abstractions is a great way to gather design feedback: if it's difficult to fake, the abstraction is likely too complex.</p> <p>The <code>SqlPostRepository</code> class is the real deal. It's responsible for connecting to a relational database and implementing the same <code>add</code> and <code>get</code> methods. This design highlights how we can effectively decouple domain logic from infrastructure logic.</p> <p>Info</p> <p>In the <code>SqlPostRepository</code> we can pass a <code>session</code> object that already handles the connection and transaction management. I ommited the SQL queries, but I think you will be able to figure them out. </p>"},{"location":"blog/2024/11/06/repository-pattern/#conclusion","title":"Conclusion","text":"<p>By using the Repository Pattern, you can decouple your application code from the data access layer. This makes it easier to switch to a different database or add extra functionality.</p> <p>And as we saw, it\u2019s easy to make a fake version of the repository for unit testing, or to swap out different storage solutions, because we\u2019ve fully decoupled the model from infrastructure concerns.</p>"},{"location":"blog/2021/01/01/hello-world/","title":"Hello World","text":"<p>This is my first post.</p>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/archive/2021/","title":"2021","text":""},{"location":"blog/category/design-patterns/","title":"Design Patterns","text":""},{"location":"blog/category/domain-driven-design/","title":"Domain Driven Design","text":""},{"location":"blog/category/hello/","title":"Hello","text":""},{"location":"blog/page/2/","title":"Index","text":""}]}